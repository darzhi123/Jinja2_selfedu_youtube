Lesson N1.

Модуль Jinja2 -> используется для обработки шаблонов.

Команда для установки Jinja2: pip install Jinja2

Lesson N1.1:
from jinja2 import Template

name = 'Федор'

tm = Template('Привет {{ name }}') # создаем экземпляр класса Template модуля jinja2 на основе шаблона Привет {{ name }}
msg = tm.render(name=name)  # в шаблоне заменяем именованный параметр на представленный аргумент

print(msg) -> Привет Федор


Внутри шаблона можно писать:
1) {%%} => cпецификатор шаблона;
2) {{}} => выражение для вставки конструкций Python в шаблон;
3) {# #} => блок комментариев;
4) # ## => строковый комментарий.


Lesson N1.2:
from jinja2 import Template

name = 'Федор'
age = 28

tm = Template('Мне {{a}} лет и зовут {{n}}')
msg = tm.render(n=name, a=age) # аргументы передаются в виде словаря и из него выдаются и подставляются

print(msg) -> Мне 28 лет и зовут Федор

Проверка на конструкции Python: (Lesson N1.3)
from jinja2 import Template

name = 'Федор'
age = 28

tm = Template('Мне {{a*2}} лет и зовут {{n.upper()}}')
msg = tm.render(n=name, a=age) # аргументы передаются в виде словаря и из него выдаются и подставляются

print(msg) -> Мне 56 лет и зовут ФЕДОР

Для работы с классом: Lesson N1.4
from jinja2 import Template

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

n = 'Федор'
a = 28

per = Person(n, a)

tm = Template('Мне {{ age * 2 }} лет и зовут {{ name }}')
msg = tm.render(age=per.age, name = per.name)

print(msg) -> Мне 56 лет и зовут Федор

или же:

tm = Template('Мне {{ p.age * 2 }} лет и зовут {{ p.name }}')
msg = tm.render(p = per)

print(msg) -> Мне 56 лет и зовут Федор

или же:
from jinja2 import Template

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def getName(self):
        return self.name

    def getAge(self):
        return self.age


n = 'Федор'
a = 28

per = Person(n, a)

tm = Template('Мне {{ p.getAge() }} лет и зовут {{ p.getName() }}')
msg = tm.render(p=per)

print(msg) -> Мне 28 лет и зовут Федор


Lesson N2.
Start_code:
import jinja2

data = """Модуль Jinja2 вместо
определения {{ name }}
подставляет соответствующее значение"""

tm = jinja2.Template(data)
msg = tm.render(name='Илья')

print(msg) => Модуль Jinja2 вместо \n определения Илья \n подставляет соответствующее значение

Способы экранирования данных в строках:
Если нужно экранирование: создайте блок {%raw%} ... {%endraw%}
Пример:
import jinja2

data = """{%raw%}Модуль Jinja2 вместо
определения {{ name }}
подставляет соответствующее значение{%endraw%}"""

tm = jinja2.Template(data)
msg = tm.render(name='Илья')

print(msg) -> Модуль Jinja2 вместо \n определения {{ name }} \nподставляет соответствующее значение

Экранирование символов:
<a href='#'>Ссылка</a> => без тегов, просто клибалеьный текст Ссылка, ведущий на #
Если же ты хочешь теги из <a href='#'>Ссылка</a> в виде текста (в браузере), тебе придется этот текст экранировать.
link = """В HTML-документе ссылки определяются так:
<a href='#'>Ссылка</a>"""
Для этого, когда пишешь объект Template, в часть {{link}} добавляешь | и фильтр e (escape, экранирование).

from jinja2 import Template

link = """В HTML-документе ссылки определяются так:
<a href='#'>Ссылка</a>"""

tm = Template("{{ link | e }}")
msg = tm.render(link=link)

print(msg) ->&lt;a href=&#39;#&#39;&gt;Ссылка&lt;/a&gt; То есть экранируются специальные символы, которые браузер
воспринимает как теги. То в веб-браузере вместо текста
В HTML-документе ссылки определяются так: Ссылка, будет
В HTML-документе ссылки определяются так: <a href='#'>Ссылка</a>

Выражение for:
Блок for позволяет создавать список на основе любого итерируемого объекта. Его архитектура:
{% for <выражение>-%}
    <повторяемый фрагмент>
{% endfor %}

from jinja2 import Template

cities = [{'id': 1, 'city': 'Москва'},
          {'id': 5, 'city': 'Тверь'},
          {'id': 7, 'city': 'Минск'},
          {'id': 8, 'city': 'Смоленск'},
          {'id': 11, 'city': 'Калуга'}]

link = '''<select name="cities">
{% for c in cities %}
    <option value="{{c['id']}}">{{c['city']}}</option>
{% endfor %}
<select>'''

tm = Template(link)
msg = tm.render(cities = cities)

print(msg)

если ставить минус перед закрывающей % или после открывающей % в цикле for - можно убрать переносы строк.


Блок для проверки условий (if):
Архитектура if:
{% if <условие> %}
    <фрагмент при истинности условия>
{% endif %}

Вставка в прошлый код:
link = '''<select name="cities">
{%- for c in cities -%}
{%- if c.id > 6 -%}}   ###################################
    <option value="{{c['id']}}">{{c['city']}}</option>
{%- endif -%} #######################################3
{% endfor %}
<select>'''

Конструкция else:
{ % else -%}
    <код для else>
Конструкция elif:
{% elif <условие> %}
    <код>

Lesson N3: Фильтры и макросы macro, call

Фильтр sum - вычисляет сумму поля коррекции

from jinja2 import Template

cars = [{'model': 'Ауди', 'price': 23_000},
          {'model': "Шкода", 'price': 17_300},
          {'model': "Вольво", 'price': 44_300},
          {'model': "Фольксваген", 'price': 21_300}
          ]

tpl = "Суммарная цена автомобилей {{ cs | sum(attribute = 'price') }}"
tm = Template(tpl)
msg = tm.render(cs = cars)

print(msg) -> Суммарная цена автомобилей 105900
В коде выше мы указываем коллекцию, для которой вызывается фильтр, | (разделитель между указыванием вставочных
материалов и фильтрами) и фильтр sum, в котором выдаем аттрибут для суммирования('price')